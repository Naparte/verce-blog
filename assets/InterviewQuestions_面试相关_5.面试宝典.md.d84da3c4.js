import{_ as l,o as i,c as e,Q as a}from"./chunks/framework.ac649e5f.js";const b=JSON.parse('{"title":"面试宝典总结","description":"","frontmatter":{},"headers":[],"relativePath":"InterviewQuestions/面试相关/5.面试宝典.md","filePath":"InterviewQuestions/面试相关/5.面试宝典.md"}'),t={name:"InterviewQuestions/面试相关/5.面试宝典.md"},p=a('<h1 id="面试宝典总结" tabindex="-1">面试宝典总结 <a class="header-anchor" href="#面试宝典总结" aria-label="Permalink to &quot;面试宝典总结&quot;">​</a></h1><h2 id="js-基础" tabindex="-1">JS 基础 <a class="header-anchor" href="#js-基础" aria-label="Permalink to &quot;JS 基础&quot;">​</a></h2><ul><li><p>0.1 + 0.2 !== 0.3</p></li><li><p>JS 类型有哪些？</p></li><li><p>大数相加、相乘算法题</p></li><li><p>修改对象得出结果笔试题</p></li><li><p>JS 类型如何判断，有哪几种方式可用</p></li><li><p>instanceof 原理</p></li><li><p>手写 instanceof</p></li><li><p>== 和 === 操作符有什么区别</p></li><li><p>== 操作符的类型转换规则</p></li><li><p>浅拷贝和深拷贝的区别是什么</p></li><li><p>JSON.parse(JSON.stringify(a)) 存在什么问题</p></li><li><p>手写深拷贝函数</p></li><li><p>如何理解原型及原型链</p></li><li><p>如何重写原型，这个在下一章节的继承小节中有解释</p></li><li><p>原型链指向</p></li><li><p>什么是提升？</p></li><li><p>什么是暂时性死区？</p></li><li><p>var、let 及 const 区别？</p></li><li><p>原型如何实现继承？</p></li><li><p>Class 如何实现继承？</p></li><li><p>Class 本质是什么？</p></li><li><p>Proxy 可以实现什么功能？</p></li><li><p>map, filter, reduce 各自有什么作用？</p></li><li><p>Map、WeakMap、Object 区别</p></li><li><p>什么是回调函数？</p></li><li><p>回调函数有什么缺点？</p></li><li><p>如何解决回调地狱问题？</p></li><li><p>你理解的 Generator 是什么？</p></li><li><p>主要考手写 Promise</p></li><li><p>Promise 的特点是什么，分别有什么优缺点？</p></li><li><p>什么是 Promise 链？</p></li><li><p>Promise 构造函数执行和 then 函数执行有什么区别？</p></li><li><p>all、race、allSettled 各有什么作用？</p></li><li><p>async 及 await 的特点</p></li><li><p>它们的优点和缺点分别是什么？</p></li><li><p>setTimeout、setInterval、requestAnimationFrame 区别是什么？</p></li><li><p>进程线程区别</p></li><li><p>JS 单线程执行带来的优缺点</p></li><li><p>什么是执行栈</p></li><li><p>如何理解 Event loop</p></li><li><p>Node 中的 Event Loop 和浏览器中的有什么区别？</p></li><li><p>process.nexttick 执行顺序？</p></li><li><p>V8 下的垃圾回收机制是怎么样的？</p></li></ul><h2 id="衍生思考题" tabindex="-1">衍生思考题 <a class="header-anchor" href="#衍生思考题" aria-label="Permalink to &quot;衍生思考题&quot;">​</a></h2><ul><li><p>思考题一：JS 分为哪两大类型？都有什么各自的特点？你该如何判断正确的类型？</p><ul><li>对于原始类型来说，你可以指出 null 和 number 存在的一些问题。</li><li>对于对象类型来说，你可以从垃圾回收的角度去切入，</li><li>也可以说一下对象类型存在深浅拷贝的问题。</li><li>对于判断类型来说，你可以去对比一下 typeof 和 instanceof 之间的区别，也可以指出 instanceof 判断类型也不是完全准确的。</li></ul></li><li><p>思考题二：你理解的原型是什么？</p><ul><li>原型小节中的总结内容，然后还可以指出一些小点，比如并不是所有函数都有 prototype 属性，</li><li>然后引申出原型链的概念，提出如何使用原型实现继承，继而可以引申出 ES6 中的 class 实现继承</li></ul></li><li><p>思考题三：bind、call 和 apply 各自有什么区别？</p><ul><li>首先肯定是说出三者的不同，如果自己实现过其中的函数，可以尝试说出自己的思路。</li><li>然后可以聊一聊 this 的内容，有几种规则判断 this 到底是什么，</li><li>this 规则会涉及到 new，那么最后可以说下自己对于 new 的理解</li></ul></li><li><p>思考题四：ES6 中有使用过什么？</p><ul><li>比如说说 class，那么 class 又可以拉回到原型的问题；</li><li>可以说说 promise，那么线就被拉到了异步的内容；</li><li>可以说说 proxy，那么如果你使用过 Vue 这个框架，就可以谈谈响应式原理的内容；</li><li>同样也可以说说 let 这些声明变量的语法，那么就可以谈及与 var 的不同，说到提升这块的内容</li></ul></li><li><p>思考题五：JS 是如何运行的？</p><ul><li>可以先说 JS 是单线程运行的，这里就可以说说你理解的线程和进程的区别。</li><li>然后讲到执行栈，接下来的内容就是涉及 Eventloop 了，微任务和宏任务的区别，哪些是微任务，哪些又是宏任务，</li><li>还可以谈及浏览器和 Node 中的 Eventloop 的不同，最后还可以聊一聊 JS 中的垃圾回收</li></ul></li></ul><p><a href="https://juejin.cn/book/6844733763675488269/section/6844733763767779342?enter_from=course_center&amp;utm_source=course_center" target="_blank" rel="noreferrer">掘金地址</a></p><h2 id="浏览器基础知识点及常考面试题" tabindex="-1">浏览器基础知识点及常考面试题 <a class="header-anchor" href="#浏览器基础知识点及常考面试题" aria-label="Permalink to &quot;浏览器基础知识点及常考面试题&quot;">​</a></h2><ul><li>事件机制</li><li>事件触发三阶段 <ul><li>注册事件</li><li>事件代理</li></ul></li><li>跨域 <ul><li>JSONP</li><li>CORS</li><li>document.domain</li><li>postMessage</li></ul></li><li>存储 <ul><li>cookie，localStorage，sessionStorage，indexDB</li><li>Service Worker</li></ul></li></ul><h2 id="浏览器缓存机制" tabindex="-1">浏览器缓存机制 <a class="header-anchor" href="#浏览器缓存机制" aria-label="Permalink to &quot;浏览器缓存机制&quot;">​</a></h2><ul><li>缓存位置 <ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li><li>网络请求</li></ul></li><li>缓存策略 <ul><li>强缓存</li><li>协商缓存</li></ul></li></ul><h2 id="浏览器渲染原理" tabindex="-1">浏览器渲染原理 <a class="header-anchor" href="#浏览器渲染原理" aria-label="Permalink to &quot;浏览器渲染原理&quot;">​</a></h2><ul><li>浏览器接收到 HTML 文件并转换为 DOM 树</li><li>将 CSS 文件转换为 CSSOM 树</li><li>生成渲染树</li><li>为什么操作 DOM 慢</li><li>什么情况阻塞渲染</li><li>重绘（Repaint）和回流</li></ul><h2 id="安全防范知识点" tabindex="-1">安全防范知识点 <a class="header-anchor" href="#安全防范知识点" aria-label="Permalink to &quot;安全防范知识点&quot;">​</a></h2><ul><li>XSS <ul><li>转义字符</li><li>CSP</li></ul></li><li>CSRF <ul><li>如何防御</li></ul></li><li>点击劫持 <ul><li>X-FRAME-OPTIONS</li><li>JS 防御</li></ul></li><li>中间人攻击</li></ul><h2 id="性能优化琐碎事" tabindex="-1">性能优化琐碎事 <a class="header-anchor" href="#性能优化琐碎事" aria-label="Permalink to &quot;性能优化琐碎事&quot;">​</a></h2><ul><li>图片优化 <ul><li>计算图片大小</li><li>图片加载优化</li></ul></li><li>DNS 预解析</li><li>节流</li><li>防抖</li><li>预加载</li><li>预渲染</li><li>懒执行</li><li>懒加载</li><li>CDN</li></ul><h2 id="webpack-性能优化" tabindex="-1">Webpack 性能优化 <a class="header-anchor" href="#webpack-性能优化" aria-label="Permalink to &quot;Webpack 性能优化&quot;">​</a></h2><ul><li>减少 Webpack 打包时间 <ul><li>优化 Loader</li><li>HappyPack</li><li>DllPlugin</li><li>代码压缩</li><li>一些小的优化点</li></ul></li><li>减少 Webpack 打包后的文件体积 <ul><li>按需加载</li><li>Scope Hoisting</li><li>Tree Shaking</li></ul></li></ul><h2 id="react-和-vue-两大框架之间的相爱相杀" tabindex="-1">React 和 Vue 两大框架之间的相爱相杀 <a class="header-anchor" href="#react-和-vue-两大框架之间的相爱相杀" aria-label="Permalink to &quot;React 和 Vue 两大框架之间的相爱相杀&quot;">​</a></h2><ul><li>MVVM</li><li>Virtual DOM</li><li>路由原理 <ul><li>Hash 模式</li><li>History 模式</li><li>两种模式对比</li></ul></li><li>Vue 和 React 之间的区别</li></ul><h2 id="vue-常考基础知识点" tabindex="-1">Vue 常考基础知识点 <a class="header-anchor" href="#vue-常考基础知识点" aria-label="Permalink to &quot;Vue 常考基础知识点&quot;">​</a></h2><ul><li><p>生命周期钩子函数</p></li><li><p>组件通信</p><ul><li>父子通信</li><li>兄弟组件通信</li><li>跨多层次组件通信</li><li>任意组件</li></ul></li><li><p>extend 能做什么</p></li><li><p>mixin 和 mixins 区别</p></li><li><p>computed 和 watch 区别</p></li><li><p>keep-alive 组件有什么作用</p></li><li><p>v-show 与 v-if 区别</p></li><li><p>组件中 data 什么时候可以使用对象</p></li><li><p>Vue 常考进阶知识点</p><ul><li>响应式原理</li><li>Object.defineProperty 的缺陷</li><li>编译过程</li><li>NextTick 原理分析</li></ul></li></ul><h2 id="react-常考基础知识点" tabindex="-1">React 常考基础知识点 <a class="header-anchor" href="#react-常考基础知识点" aria-label="Permalink to &quot;React 常考基础知识点&quot;">​</a></h2><ul><li><p>生命周期</p></li><li><p>setState</p></li><li><p>性能优化</p></li><li><p>通信</p><ul><li>父子通信</li><li>兄弟组件通信</li><li>跨多层次组件通信</li><li>任意组件</li></ul></li><li><p>React 常考进阶知识点</p></li><li><p>HOC 是什么？相比 mixins 有什么优点？</p></li><li><p>事件机制</p></li><li><p>更新内容</p></li></ul><h2 id="监控" tabindex="-1">监控 <a class="header-anchor" href="#监控" aria-label="Permalink to &quot;监控&quot;">​</a></h2><ul><li>页面埋点</li><li>性能监控</li><li>异常监控</li></ul><h2 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h2><ul><li>头部</li><li>状态机 <ul><li>建立连接三次握手</li><li>断开链接四次握手</li></ul></li><li>ARQ 协议 <ul><li>停止等待 ARQ</li><li>连续 ARQ</li><li>累计确认</li></ul></li><li>滑动窗口 <ul><li>Zero 窗口</li></ul></li><li>拥塞处理 <ul><li>慢开始算法</li><li>拥塞避免算法</li><li>快速重传</li><li>TCP New Ren 改进后的</li></ul></li></ul><h2 id="http-2-及-http-3" tabindex="-1">HTTP/2 及 HTTP/3 <a class="header-anchor" href="#http-2-及-http-3" aria-label="Permalink to &quot;HTTP/2 及 HTTP/3&quot;">​</a></h2><ul><li>HTTP/2</li><li>二进制传输</li><li>多路复用</li><li>Header 压缩</li><li>服务端 Push</li><li>HTTP/3 <ul><li>QUIC</li></ul></li></ul><h2 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h2><ul><li>工厂模式</li><li>单例模式</li><li>适配器模式</li><li>装饰模式</li><li>代理模式</li><li>发布-订阅模式</li><li>外观模式</li></ul>',32),r=[p];function u(o,n,s,c,h,d){return i(),e("div",null,r)}const P=l(t,[["render",u]]);export{b as __pageData,P as default};
