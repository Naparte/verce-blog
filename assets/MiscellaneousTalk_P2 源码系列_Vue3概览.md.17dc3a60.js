import{_ as t,o as s,c as a,Q as e}from"./chunks/framework.ac649e5f.js";const l=""+new URL("hoisted.d245ddef.jpg",import.meta.url).href,v=JSON.parse('{"title":"Vue3","description":"","frontmatter":{},"headers":[],"relativePath":"MiscellaneousTalk/P2 源码系列/Vue3概览.md","filePath":"MiscellaneousTalk/P2 源码系列/Vue3概览.md"}'),n={name:"MiscellaneousTalk/P2 源码系列/Vue3概览.md"},o=e(`<h1 id="vue3" tabindex="-1">Vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;Vue3&quot;">​</a></h1><h2 id="vue-设计初衷" tabindex="-1">Vue 设计初衷 <a class="header-anchor" href="#vue-设计初衷" aria-label="Permalink to &quot;Vue 设计初衷&quot;">​</a></h2><ul><li>响应式想要解决的问题</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">// 要始终保持b是a的2倍，需要 指令式 的调用方法</span></span>
<span class="line"><span style="color:#E1E4E8;">a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">// 响应式想要解决的是类似 fx = A * 2 这类有明确关系的中间处理函数的维护成本；保证A和B的同步</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">// 要始终保持b是a的2倍，需要 指令式 的调用方法</span></span>
<span class="line"><span style="color:#24292E;">a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#6A737D;">// 响应式想要解决的是类似 fx = A * 2 这类有明确关系的中间处理函数的维护成本；保证A和B的同步</span></span></code></pre></div><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 衍生：加入state的a属性修改，界面dom要显示 出来；</span></span>
<span class="line"><span style="color:#6A737D;"> 维护的是状态和dom输出之间的逻辑（声明式渲染） --&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">span</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">{{state.a * 10}}</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">span</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">onStateChanged (()=&gt;{ view = render(state) })</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">&lt;!-- 衍生：加入state的a属性修改，界面dom要显示 出来；</span></span>
<span class="line"><span style="color:#6A737D;"> 维护的是状态和dom输出之间的逻辑（声明式渲染） --&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">span</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">{{state.a * 10}}</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">span</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">onStateChanged (()=&gt;{ view = render(state) })</span></span></code></pre></div><ul><li>vue 实现了追踪变量的依赖（称之为追踪器），然后执行对应的“副作用”逻辑</li></ul><h2 id="vue2-和-vue3-的不同" tabindex="-1">Vue2 和 Vue3 的不同 <a class="header-anchor" href="#vue2-和-vue3-的不同" aria-label="Permalink to &quot;Vue2 和 Vue3 的不同&quot;">​</a></h2><ol><li>双向数据绑定原理不同</li><li>是否支持碎片 <ol><li>vue2：vue2 不支持碎片。</li><li>vue3：vue3 支持碎片（Fragments），就是说可以拥有<code>多个根节点</code>。</li></ol></li><li>API 类型不同 <ol><li>vue2：vue2 使用选项类型 api，选项型 api 在代码里分割了不同的属性：data,computed,methods 等</li><li>vue3：vue3 使用 Composition API ，相比于旧的 api 使用属性来分组，这样代码会更加简便和整洁</li></ol></li><li>定义数据变量和方法不同 <ol><li>vue2：vue2 是把数据放入 data 中，在 vue2 中定义数据变量是 data(){} ，创建的方法要在 methods:{} 中</li><li>vue3：vue3 就需要使用一个新的 setup()方法，此方法在组件初始化构造的时候触发</li></ol></li><li>生命周期的变化 <table><thead><tr><th>Vue2 生命周期钩子</th><th>Vue3 生命周期钩子</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate()</td><td>setup()</td><td>组件实例开始创建，初始化数据观测和事件方法之前</td></tr><tr><td>created()</td><td>-</td><td>组件实例已经完全创建，属性和方法完成绑定，但 DOM 还未生成</td></tr><tr><td>beforeMount()</td><td>onBeforeMount()</td><td>在挂载开始之前调用，相关的 render 函数首次被调用</td></tr><tr><td>mounted()</td><td>onMounted()</td><td>组件实例被挂载到 DOM 中，完成了模板渲染和虚拟 DOM 转换为真实 DOM 的过程</td></tr><tr><td>beforeUpdate()</td><td>onBeforeUpdate()</td><td>组件数据更新之前调用，即将重新渲染但新的虚拟 DOM 尚未生成时触发</td></tr><tr><td>updated()</td><td>onUpdated()</td><td>组件完成数据更新和新的虚拟 DOM 生成后，DOM 更新完毕时调用</td></tr><tr><td>beforeDestroy()</td><td>onBeforeUnmount()</td><td>在实例销毁前调用，此时组件仍然完全可用，可以在这时执行清理操作</td></tr><tr><td>destroyed()</td><td>onUnmounted()</td><td>组件实例从 DOM 中移除，并解绑所有数据绑定、指令及事件监听器之后调用</td></tr></tbody></table></li></ol><p>注：Vue3 中的 <code>setup()</code> 函数替代了 Vue2 的多个生命周期钩子，它在组件实例创建之初运行，可以在其中返回对象以暴露响应式属性和生命周期钩子。</p><p>此外，Vue3 中没有直接与 Vue2 <code>created()</code> 对应的钩子函数，需要在 <code>setup()</code> 函数内部处理相应的逻辑。</p><ol start="6"><li><p>PatchFlag 带来的性能提升</p><ul><li>Vue 2.x 中的虚拟 DOM 是全量对比的模式，而到了 Vue 3.0 开始，新增了静态标记（PatchFlag）</li><li>Vue3 在模板编译阶段 用 hoisted、openBlock 进行 静态提升；由 Vue2 的 vdom 全量对比改成只对比修改过的 dom</li></ul></li></ol><p><img src="`+l+'" alt="hoisted、openBlock"></p><ol start="7"><li>事件缓存</li></ol><ul><li>Vue3 的 cacheHandler 可在第一次渲染后缓存我们的事件。相比于 Vue2 无需每次渲染都传递一个新函数</li></ul><ol start="8"><li>打包优化</li></ol><ul><li>Tree-shaking：模块打包 webpack、rollup 等中的概念。移除 JavaScript 上下文中未引用的代码。主要依赖于 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用</li></ul><h2 id="vue3-仓库目录概览" tabindex="-1">Vue3 仓库目录概览 <a class="header-anchor" href="#vue3-仓库目录概览" aria-label="Permalink to &quot;Vue3 仓库目录概览&quot;">​</a></h2><table><thead><tr><th>包名</th><th>描述</th></tr></thead><tbody><tr><td>@vue/shared</td><td>包含通用的工具函数和常量，是其他包的依赖项</td></tr><tr><td>@vue/reactivity</td><td>实现了 Vue.js 的响应式系统，包括依赖追踪和触发更新等功能</td></tr><tr><td>@vue/compiler-core</td><td>Vue.js 编译器的核心包，将模板编译为渲染函数</td></tr><tr><td>@vue/runtime-core</td><td>Vue.js 运行时的核心包，提供组件实例化和虚拟 DOM 渲染等功能</td></tr><tr><td>@vue/runtime-dom</td><td>Vue.js 运行时的 DOM 版本包，提供在浏览器环境下运行 Vue.js 的功能</td></tr><tr><td>@vue/compiler-dom</td><td>Vue.js 编译器的 DOM 版本包，将模板编译为浏览器可执行的渲染函数</td></tr><tr><td>@vue/server-renderer</td><td>Vue.js 服务器端渲染（SSR）的渲染器包，用于在服务器端渲染 Vue.js 应用</td></tr><tr><td>@vue/compiler-ssr</td><td>Vue.js 编译器的服务器端渲染（SSR）版本包，将模板编译为服务器端可执行的渲染函数</td></tr><tr><td>@vue/test-utils</td><td>Vue.js 的测试工具包，用于编写和运行单元测试和集成测试</td></tr><tr><td>@vue/use</td><td>Vue.js 的 Composition API 的实现包，用于支持组合式开发</td></tr></tbody></table><h2 id="vue-shared-包概览" tabindex="-1">@vue/shared 包概览 <a class="header-anchor" href="#vue-shared-包概览" aria-label="Permalink to &quot;@vue/shared 包概览&quot;">​</a></h2><table><thead><tr><th>文件名</th><th>描述</th></tr></thead><tbody><tr><td>codeframe.ts</td><td>代码框架生成工具</td></tr><tr><td>domAttrConfig.ts</td><td>DOM 属性配置</td></tr><tr><td>domTagConfig.ts</td><td>DOM 标签配置</td></tr><tr><td>escapeHtml.ts</td><td>HTML 转义工具函数</td></tr><tr><td>general.ts</td><td>通用工具函数</td></tr><tr><td>globalsAllowList.ts</td><td>全局变量白名单配置</td></tr><tr><td>index.ts</td><td>入口文件，导出了@vue/shared 包中的各种工具函数</td></tr><tr><td>looseEqual.ts</td><td>宽松相等性检查工具函数</td></tr><tr><td>makeMap.ts</td><td>创建映射表的工具函数</td></tr><tr><td>normalizeProp.ts</td><td>属性规范化工具函数</td></tr><tr><td>patchFlags.ts</td><td>补丁标记常量定义</td></tr><tr><td>shapeFlags.ts</td><td>节点类型标记常量定义</td></tr><tr><td>slotFlags.ts</td><td>插槽标记常量定义</td></tr><tr><td>toDisplayString.ts</td><td>将值转换为显示字符串的工具函数</td></tr><tr><td>typeUtils.ts</td><td>类型相关的工具函数</td></tr></tbody></table><p><code>@vue/shared</code>这些文件主要提供了不同的工具函数和配置，用于支持 Vue.js 的核心功能和特性的实现。</p>',21),p=[o];function d(r,c,i,u,y,h){return s(),a("div",null,p)}const m=t(n,[["render",d]]);export{v as __pageData,m as default};
